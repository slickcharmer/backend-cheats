# Шпаргалка по Bash скриптам

<div align="right"><a href="https://github.com/cheatsnake/backend-cheats#%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D1%8B-bash">Вернуться на главную страницу ⬆️</a></div>

Скрипты Bash имеют расширение `.sh`:
```sh
touch script.sh
```

Хорошей практикой считается указывать путь до вашего терминала вначале каждого скрипта:
```sh
#! /bin/bash
```
> Этот прием называется **shebang**, подробнее можно почитать [тут](https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D0%B1%D0%B0%D0%BD%D0%B3_(Unix))

Список доступных терминалов в вашей системе можно посмотреть с помощью этой команды:
```sh
cat /etc/shells
```

## Hello world

```sh
#! /bin/bash
echo "Hello world"
```

Запуск скрипта:
```
$ bash script.sh
```

Скрипт можно сделать исполняемым файлом и запускать без команды `bash`:
```
$ chmod +x script.sh
```
```
$ ./script.sh
```

## Комментарии

Однострочные комментарии:
```sh
# Это просто коммент
# И это тоже
echo "Hello from bash" # эта команда выводит строку в консоль
```

Мультистрочные комментарии:
```sh
: 'Мультистрочные комментарии очень удобны
для подробного описания ваших скриптов.
Успользуйте их с умом!'
```

## Переменные

```sh
MY_STRING="bash is cool"
echo $MY_STRING # Вывод значения переменной
```
> Имя переменной не должно начинаться с цифры

## Пользовательский ввод

Команда `read` читает пользовательский ввод и записывает его в указанную переменную:
```sh
echo "Введите ваше имя:"
read NAME
echo "Привет $NAME!"
```
> Если переменная не указана, то команда `read` по умолчанию сохранит все данные в переменную `REPLY`


Можно записывать несколько переменных. Для этого при вводе их нужно разделять пробелом:
```sh
read V1 V2 V3
echo "1 переменная: $V1"
echo "2 переменная: $V2"
echo "3 переменная: $V3"
```
```
$ bash script.sh
$ hello world some other text
1 переменная: hello
2 переменная: world
3 переменная: some other text
```

Флаг `-a` позволяет создать массив в который будут записываться строки пользовательского ввода разделенные пробелом:
```sh
read -a NAMES
echo "Массив имён: ${NAMES[0]}, ${NAMES[1]}, ${NAMES[2]}"
```
```
$ bash script.sh
Alex Mike John
Массив имён: Alex, Mike, John
```

Флаг `-p` позволяет не переносить пользовательский ввод на следующую строку.

Флаг `-s` позволяет скрыть вводимые символы (как это происходит при вводе пароля).
```sh
read -p "Введите ваш логин: " LOGIN
read -sp "Введите ваш пароль: " PASSWD
```
```
$ bash script.sh
Введите ваш логин: bash_hacker
Введите ваш пароль: 
```

## Передача аргументов

Аргументы это просто значения, которые могут быть указаны при запуске скрипта.

Всем переданным аргументам присваивается уникальное имя равное их порядковому номеру:
```sh
echo "Аргумент 1 - $1; aргумент 1 - $2; aргумент 1 - $3."
```
```
$ bash script.sh hello test 1337
Аргумент 1 - hello; aргумент 1 - test; aргумент 1 - 1337.
```

Нулевой аргумент всегда равен названию файла со скриптом:
```sh
echo "Вы запустили файл $0"
```
```
$ bash script.sh
Вы запустили файл script.sh
```

Все аргументы можно положить в именованный массив:
```sh
args=("$@")
echo "Полученные аргументы: ${args[0]}, ${args[1]}, ${args[2]}."
```
```
$ bash script.sh some values 123
Полученные аргументы: some, values, 123
```
> `@` - это название массива по умолчанию, который хранит все аргументы (за исключением нулевого)

Количество переданных аргументов (за исключением нулевого) хранится в переменной `#`:
```sh
echo "Всего получено аргументов: $#"
```

## Условия if else

Условия всегда начинаются с ключевого слова `if` и заканчиваются на `fi`:
```sh
echo "Введите ваш возраст:"
read AGE

if (($AGE >= 18)) 
then
	echo "Доступ разрешен"
else
	echo "Доступ запрещен"
fi
```
```
$ bash script.sh
Введите ваш возраст:
19
Доступ разрешен

$ bash script.sh
Введите ваш возраст:
16
Доступ запрещен
```

Условий может быть сколько угодно много, для этого используется конструкция `elif`, которая также как `if` может проверять условия:
```sh
read COMMAND

if [ $COMMAND = "help" ] 
then
	echo "Доступные команды:"
	echo "ping - вернет строку PONG"
	echo "version - вернет номер версии программы"
elif [ $COMMAND = "ping" ] 
then
	echo "PONG"
elif [ $COMMAND = "version" ] 
then
	echo "v1.0.0"
else
	echo "Команда не определена. Воспользуйтесь командой 'help' для справки"
fi
```
> Обратите внимание, что после конструкций `if` и `elif` всегда следует строчка с ключевым словом `then` <br>
> Так же не забывайте отделять условия пробелами внутри фигурных скобок -> `[ condition ]`

## Операторы условий

Для цифр и строк могут использоваться разные операторы сравнения. Полные их списки с примерами приведены в таблицах ниже.
> Обратите внимания, что разные операторы используются с определенными скобками

### Операторы сравнения для чисел

| Оператор | Описание             | Пример             |
| -------- | -------------------- | ------------------ |
| -eq      | равняется ли         | if [ $age -eq 18 ] |
| -ne      | не равняется         | if [ $age -ne 18 ] |
| -gt      | больше чем           | if [ $age -gt 18 ] |
| -ge      | больше чем или равно | if [ $age -ge 18 ] |
| -lt      | меньше чем           | if [ $age -lt 18 ] |
| -le      | меньше чем или равно | if [ $age -le 18 ] |
| >        | больше чем           | if (($age > 18))   |
| <        | меньше чем           | if (($age < 18))   |
| =>       | больше чем или равно | if (($age => 18))  |
| <=       | меньше чем или равно | if (($age <= 18))  |

### Операторы сравнения для строк

| Оператор | Описание                                    | Пример                   |
| -------- | ------------------------------------------- | ------------------------ |
| =        | проверка на равенство                       | if [ $str = "hello" ]    |
| ==       | проверка на равенство                       | if [ $str == "hello" ]   |
| !=       | проверка на НЕ равенство                    | if [ $str != "hello" ]   |
| <        | сравнение меньше чем по ASCII коду символов | if [[ $str < "hello" ]]  |
| >        | сравнение больше чем по ASCII коду символов | if [[ $str > "hello" ]]  |
| -z       | проверка пустая ли строка                   | if [ -z $str ]           |
| -n       | проверка есть ли в строке хоть один символ  | if [ -n $str ]           |

Так же существуют операторы для проверки различных условий над файлами.

### Операторы для проверки файлов

| Оператор | Описание                                                                          | Пример          |
| -------- | --------------------------------------------------------------------------------- | --------------- |
| -e       | проверяет, существует ли файл                                                     | if [ -e $file ] |
| -s       | проверяет, пустой ли файл                                                         | if [ -s $file ] |
| -f       | проверяет, является ли файл обычным файлом, а не каталогом или специальным файлом | if [ -f $file ] |
| -d       | проверяет, является ли файл каталогом                                             | if [ -d $file ] |
| -r       | проверяет, доступен ли файл для чтения                                            | if [ -r $file ] |
| -w       | проверяет, доступен ли файл для записи                                            | if [ -w $file ] |
| -x       | проверяет, является ли файл исполяемым                                            | if [ -x $file ] |

## Логические операторы

Условия с оператором "И" возвращают истину только в том случае, когда все условия истины.
> Существует несколько вариантов написания условий с логическими операторами

```sh
if [ $age -ge 18 ] && [ $age -le ]
```
```sh
if [ $age -ge 18 -a $age -le ]
```
```sh
if [[ $age -ge 18 && $age -le ]]
```

Условия с оператором "ИЛИ" возвращают истину в том случае, когда хотя бы одно условие истинно.

```sh
if [ -r $file ] || [ -w $file ]
```
```sh
if [ -r $file -o -w $file ]
```
```sh
if [[ -r $file || -w $file ]]
```

## Арифметические операторы

```bash
num1=10
num2=5

# Сложение
echo $((num1 + num2))      # 15
echo $(expr $num1 + $num2) # 15

# Вычитание
echo $((num1 - num2))      # 5
echo $(expr $num1 - $num2) # 5

# Умножение
echo $((num1 * num2))       # 50
echo $(expr $num1 \* $num2) # 50

# Деление
echo $((num1 / num2))      # 2
echo $(expr $num1 / $num2) # 2

# Остаток от деления
echo $((num1 % num2))      # 0
echo $(expr $num1 % $num2) # 0
```
> Обратите внимание, что при использовании умножения с ключевым словом `expr` необходимо использовать косую черту.

## Конструкция switch case

Не всегда удобно использовать конструкции if/elif для большого количества условий. Для этого лучше подойдет конструкция case:

```sh
read COMMAND

case $COMMAND in
	"/help" )
		echo "Вы открыли справочное меню" ;;
	"/ping" )
		echo "PONG" ;;
	"/version" )
		echo "Текущая версия: 1.0.0" ;;
	* ) 
		echo "Такой команды нет :(" ;;		
esac
```

> Случай со звездочкой * отработает лишь в том случае, если не подойдет ни одно из условий выше.

## Массивы

Массивы позволяют хранить целую коллекцию данных в одной переменной. С этой переменной можно удобно и легко взаимодействовать:

```sh
array=('aaa' 'bbb' 'ccc' 'ddd')

echo "Элементы массива: ${array[@]}"
echo "Первый элемент массива: ${array[0]}"
echo "Индексы элементов массива: ${!array[@]}"

array_length=${#array[@]}
echo "Длинна массива: ${array_length}"
echo "Последний элемент массива: ${array[$((array_length - 1))]}"
``` 
```
$ bash script.sh
Элементы массива: aaa bbb ccc ddd
Первый элемент массива: aaa
Индексы элементов массива: 0 1 2 3
Длинна массива: 4
Последний элемент массива: ddd
```
> Обратите внимание, что элементы массива разделются пробелом без запятой.

Элементы массива можно добавлять/перезаписывать/удалять по ходу выполнения скрипта:

```sh
array=('a' 'b' 'c')

array[3]='d'
echo ${array[@]} # a b c d

array[0]='x'
echo ${array[@]} # x b c d

array[0]='x'
echo ${array[@]} # x b c d

unset array[2]
echo ${array[@]} # x b d
```