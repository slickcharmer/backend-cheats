# Шпаргалка по Bash скриптам

<div align="right"><a href="https://github.com/cheatsnake/backend-cheats#%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D1%8B-bash">Вернуться на главную страницу ⬆️</a></div>

Скрипты Bash имеют расширение `.sh`:
```sh
touch script.sh
```

Хорошей практикой считается указывать путь до вашего терминала вначале каждого скрипта:
```sh
#! /bin/bash
```
> Этот прием называется **shebang**, подробнее можно почитать [тут](https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D0%B1%D0%B0%D0%BD%D0%B3_(Unix))

Список доступных терминалов в вашей системе можно посмотреть с помощью этой команды:
```sh
cat /etc/shells
```

## Hello world

```sh
#! /bin/bash
echo "Hello world"
```

Запуск скрипта:
```
bash script.sh
```

Скрипт можно сделать исполняемым файлом и запускать без команды `bash`:
```
chmod +x script.sh
```
```
./script.sh
```

## Комментарии

Однострочные комментарии:
```sh
# Это просто коммент
# И это тоже
echo "Hello from bash" # эта команда выводит строку в консоль
```

Мультистрочные комментарии:
```sh
: 'Мультистрочные комментарии очень удобны
для подробного описания ваших скриптов.
Успользуйте их с умом!'
```

## Переменные

```sh
MY_STRING="bash is cool"
echo $MY_STRING # Вывод значения переменной
```
> Имя переменной не должно начинаться с цифры

## Пользовательский ввод

Команда `read` читает пользовательский ввод и записывает его в указанную переменную:
```sh
echo "Введите ваше имя:"
read NAME
echo "Привет $NAME!"
```
> Если переменная не указана, то команда `read` по умолчанию сохранит все данные в переменную `REPLY`


Можно записывать несколько переменных. Для этого при вводе их нужно разделять пробелом:
```sh
read V1 V2 V3
echo "1 переменная: $V1"
echo "2 переменная: $V2"
echo "3 переменная: $V3"
```
```
> user:~$ bash script.sh
> hello world some other text
> 1 переменная: hello
> 2 переменная: world
> 3 переменная: some other text
```

Флаг `-a` позволяет создать массив в который будут записываться строки пользовательского ввода разделенные пробелом:
```sh
read -a NAMES
echo "Массив имён: ${NAMES[0]}, ${NAMES[1]}, ${NAMES[2]}"
```
```
> user:~$ bash script.sh
> Alex Mike John
> Массив имён: Alex, Mike, John
```

Флаг `-p` позволяет не переносить пользовательский ввод на следующую строку

Флаг `-s` позволяет скрыть вводимые символы (как это происходит при вводе пароля)
```sh
read -p "Введите ваш логин: " LOGIN
read -sp "Введите ваш пароль: " PASSWD
```
```
> user:~$ bash script.sh
> Введите ваш логин: bash_hacker
> Введите ваш пароль: 
```

## Передача аргументов

Аргументы это просто значения, которые могут быть указаны при запуске скрипта.

Всем переданным аргументам присваивается уникальное имя равное их порядковому номеру:
```sh
echo "Аргумент 1 - $1; aргумент 1 - $2; aргумент 1 - $3."
```
```
> user:~$ bash script.sh hello test 1337
> Аргумент 1 - hello; aргумент 1 - test; aргумент 1 - 1337.
```

Нулевой аргумент всегда равен названию файла со скриптом:
```sh
echo "Вы запустили файл $0"
```
```
> user:~$ bash script.sh
> Вы запустили файл script.sh
```

Все аргументы можно положить в именованный массив:
```sh
args=("$@")
echo "Полученные аргументы: ${args[0]}, ${args[1]}, ${args[2]}."
```
```
> user:~$ bash script.sh some values 123
> Полученные аргументы: some, values, 123
```
> `@` - это название массива по умолчанию, который хранит все аргументы (за исключением нулевого)

Количество переданных аргументов (за исключением нулевого) хранится в переменной `#`:
```sh
echo "Всего получено аргументов: $#"
```

## Условия if else

Условия всегда начинаются с ключевого слова `if` и заканчиваются на `fi`:
```sh
echo "Введите ваш возраст:"
read AGE

if (($AGE >= 18)) 
then
	echo "Доступ разрешен"
else
	echo "Доступ запрещен"
fi
```
```
> user:~$ bash script.sh
> Введите ваш возраст:
> 19
> Доступ разрешен
>
> user:~$ bash script.sh
> Введите ваш возраст:
> 16
> Доступ запрещен
```

Условий может быть сколько угодно много, для этого используется конструкция `elif`, которая также как `if` может проверять условия:
```sh
read COMMAND

if [ $COMMAND = "help" ] 
then
	echo "Доступные команды:"
	echo "ping - вернет строку PONG"
	echo "version - вернет номер версии программы"
elif [ $COMMAND = "ping" ] 
then
	echo "PONG"
elif [ $COMMAND = "version" ] 
then
	echo "v1.0.0"
else
	echo "Команда не определена. Воспользуйтесь командой 'help' для справки"
fi
```
> Обратите внимание, что после конструкций `if` и `elif` всегда следует строчка с ключевым словом `then` <br>
> Так же не забывайте отделять условия пробелами внутри фигурных скобок -> `[ condition ]`

## Операторы для условий

Для цифр и строк могут использоваться разные операторы сравнения. Полные их списки с примерами приведены в таблицах ниже
> Обратите внимания, что разные операторы используются с определенными скобками

### Операторы сравнения для чисел

| Оператор | Описание             | Пример             |
| -------- | -------------------- | ------------------ |
| -eq      | равняется ли         | if [ $age -eq 18 ] |
| -ne      | не равняется         | if [ $age -ne 18 ] |
| -gt      | больше чем           | if [ $age -gt 18 ] |
| -ge      | больше чем или равно | if [ $age -ge 18 ] |
| -lt      | меньше чем           | if [ $age -lt 18 ] |
| -le      | меньше чем или равно | if [ $age -le 18 ] |
| >        | больше чем           | if (($age > 18))   |
| <        | меньше чем           | if (($age < 18))   |
| =>       | больше чем или равно | if (($age => 18))  |
| <=       | меньше чем или равно | if (($age <= 18))  |

### Операторы сравнения для строк

| Оператор | Описание                                    | Пример                   |
| -------- | ------------------------------------------- | ------------------------ |
| =        | проверка на равенство                       | if [ $str = "hello" ]    |
| ==       | проверка на равенство                       | if [ $str == "hello" ]   |
| !=       | проверка на НЕ равенство                    | if [ $str != "hello" ]   |
| <        | сравнение меньше чем по ASCII коду символов | if [[ $str < "hello" ]]  |
| >        | сравнение больше чем по ASCII коду символов | if [[ $str > "hello" ]]  |
| -z       | проверка пустая ли строка                   | if [ -z $str ]           |
| -n       | проверка есть ли в строке хоть один символ  | if [ -n $str ]           |

Так же существуют операторы для проверки различных условий над файлами

### Операторы для проверки файлов

| Оператор | Описание                                                                          | Пример          |
| -------- | --------------------------------------------------------------------------------- | --------------- |
| -e       | проверяет, существует ли файл                                                     | if [ -e $file ] |
| -s       | проверяет, пустой ли файл                                                         | if [ -s $file ] |
| -f       | проверяет, является ли файл обычным файлом, а не каталогом или специальным файлом | if [ -f $file ] |
| -d       | проверяет, является ли файл каталогом                                             | if [ -d $file ] |
| -r       | проверяет, доступен ли файл для чтения                                            | if [ -r $file ] |
| -w       | проверяет, доступен ли файл для записи                                            | if [ -w $file ] |
| -x       | проверяет, является ли файл исполяемым                                            | if [ -x $file ] |
